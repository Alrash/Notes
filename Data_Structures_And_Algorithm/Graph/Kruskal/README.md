#Kruskal

##算法思路
1. 将图中边安从小到大排序
2. 将选中的边的两个端点加入一个集合（若任意一个端点在一个集合内，另一个不在任何集合，则将另一个端点加入这个集合；若都不在任意集合内，则两个端点自成一个集合；若在两个不同的集合内，则将两个集合合并）
3. 抛弃边的条件：两个端点在同一个集合内
**适用状况：稀疏图，因为可能需要查询所有的边**

##图例


##算法需解决的问题


##代码示例
```cpp
```

##小部分改进
最小生成树所需结点和边数的关系：N个结点，N-1条边<br>
所以在for循环的时候，找到N-1条边就可以跳出循环，则加一个参数count记录边数，将原来的终止条件改为count > 0
